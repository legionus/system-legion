# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright (C) 2024  Alexey Gladkov <gladkov.alexey@gmail.com>

import os
import os.path
import logging
import zipfile
import shutil
import tempfile
import urllib.request
import hashlib

import portage
from portage.util import writemsg_level
from portage.sync.syncbase import NewBase


class ZipFile(NewBase):
    """ZipFile sync module"""

    short_desc = "Perform sync operations on GitHub repositories"

    @staticmethod
    def name():
        return "ZipFile"

    def __init__(self):
        NewBase.__init__(self, "emerge", ">=sys-apps/portage-2.3")

    def exists(self, **kwargs):
        """Tests whether the repo actually exists"""
        return os.path.exists(os.path.join(self.repo.location, ".desc"))

    def retrieve_head(self, **kwargs):
        """Get information about the head commit"""
        if kwargs:
            self._kwargs(kwargs)
        last_sync = portage.grabfile(os.path.join(self.repo.location, ".desc"))
        ret = (1, False)
        if last_sync:
            try:
                ret = (os.EX_OK, last_sync[0].split()[0])
            except IndexError:
                pass
        return ret

    def new(self, **kwargs):
        """Do the initial clone of the repository"""
        if kwargs:
            self._kwargs(kwargs)

        # initial checkout
        zip_uri = self.repo.sync_uri

        with urllib.request.urlopen(zip_uri) as response:
            with tempfile.NamedTemporaryFile(delete=False) as tmp_file:
                shutil.copyfileobj(response, tmp_file)
            zip_file = tmp_file.name

        if not zipfile.is_zipfile(zip_file):
            msg = "!!! file is not a zip archive."
            self.logger(self.xterm_titles, msg)
            writemsg_level(msg + "\n", noiselevel=-1, level=logging.ERROR)

            os.unlink(zip_file)

            return (1, False)

        # Drop previous tree
        shutil.rmtree(self.repo.location)

        with zipfile.ZipFile(zip_file) as archive:
            strip_comp = 0

            for f in archive.namelist():
                f = os.path.normpath(f)
                if os.path.basename(f) == "profiles":
                    strip_comp = f.count("/")
                    break

            for n in archive.infolist():
                p = os.path.normpath(n.filename)

                if os.path.isabs(p):
                    continue

                parts = p.split("/")
                dstpath = os.path.join(self.repo.location, *parts[strip_comp:])

                if n.is_dir():
                    os.makedirs(dstpath, mode=0o755, exist_ok=True)
                    continue

                with archive.open(n) as srcfile:
                    with open(dstpath, "wb") as dstfile:
                        shutil.copyfileobj(srcfile, dstfile)

        with open(zip_file, "rb") as archive:
            algo = "sha256"
            digest = hashlib.file_digest(archive, algo)
            hexdigest = digest.hexdigest()

            with open(os.path.join(self.repo.location, ".desc"), "w") as descfile:
                descfile.write(f"{algo}:{hexdigest}\n")

        os.unlink(zip_file)

        return (os.EX_OK, True)

    def update(self):
        """
        Internal function to update an existing repository from zip archive.

        @return: tuple of return code (0=success), whether the cache
                needs to be updated
        @rtype: (int, bool)
        """

        return self.new()

#!/bin/sh -eux

info="$(readelf --wide --segments /bin/sh)" || {
	echo "/bin/sh: unable to fetch ELF segment headers"
	exit 1
}

interp="$(printf '%s\n' "$info" |
	sed -ne 's,^[[:space:]]*\[Requesting program interpreter: \(/[^]]\+\)\]$,\1,p')"

[ -n "$interp" ]
[ -x "$interp" ]

# These are a rather unobvious.
# lrwxrwxrwx 1 root root 2 Sep 14 18:25 /bin/ex -> vi
# lrwxrwxrwx 1 root root 2 Sep 14 18:25 /bin/rview -> vi
# lrwxrwxrwx 1 root root 3 Sep 14 18:25 /usr/bin/ex -> vim
# lrwxrwxrwx 1 root root 3 Sep 14 18:25 /usr/bin/rview -> vim

rm -v /bin/ex
rm -v /bin/rview

tmpdir=
cleanup_tmpdir()
{
	[ -z "$tmpdir" ] || rm -rf -- "$tmpdir"
	exit "$@"
}

tmpdir=$(mktemp -dt -- "${0##*/}.XXXXXXXX")
trap 'cleanup_tmpdir $?' EXIT
trap 'exit 143' HUP INT QUIT PIPE TERM

is_dir_empty() {
	local d="$1"; shift

	if [ -n "$(find "$d" -maxdepth 0 -type d -empty 2>/dev/null)" ]; then
		return 0
	fi

	return 1
}

cmp() {
	local d="$1"; shift
	local p rp rup
	find "$d" -mindepth 1 \
		>"$tmpdir"/cmp_root
	find "/usr$d" -mindepth 1 \
		>"$tmpdir"/cmp_usr
	sed 's@^/usr@@' -i "$tmpdir"/cmp_usr
	sort -o "$tmpdir"/cmp_root{,}
	sort -o "$tmpdir"/cmp_usr{,}
	comm -12 "$tmpdir"/cmp_root "$tmpdir"/cmp_usr \
		>"$tmpdir"/cmp_out
	while read p; do {
		rp="$(realpath "$p")"
		rup="$(realpath "/usr$p")"
		printf '%s\t%s\t%s\n' "$p" "$rp" "$rup"
	} </dev/null; done <"$tmpdir"/cmp_out
}

dirs='/bin /lib /lib64 /libx32 /sbin'

for d in $dirs; do
	cmp "$d" >"$tmpdir"/list
	sort -r -o "$tmpdir"/list{,}
	while read path real_path real_upath; do {
		upath="/usr$path"
		if [ "$real_path" = "$real_upath" ]; then
			:
		elif [ -d "$path" ] && [ -d "$upath" ]; then
			:
		else
			echo >&2 "Unable to merge $path"
			exit 1
		fi
	} </dev/null; done <"$tmpdir"/list
done

for d in $dirs; do
	cmp "$d" >"$tmpdir"/list
	sort -r -o "$tmpdir"/list{,}
	while read path real_path real_upath; do {
		upath="/usr$path"
		if [ "$real_path" = "$real_upath" ]; then
			if [ -L "$path" ]; then
				rm -v "$path"
			else
				rm -v "$upath"
				mv -T -v "$path" "$upath"
			fi
		elif [ -d "$path" ] && [ -d "$upath" ]; then
			if is_dir_empty "$path"; then
				rmdir -v "$path"
			else
				mv -v "$path"/* "$upath"/
				rmdir -v "$path"
			fi
		fi
	} </dev/null; done <"$tmpdir"/list

	cmp "$d" >"$tmpdir"/list
	if [ -s "$tmpdir"/list ]; then
		echo 'Failed to merge usr'
		echo 'Conflicting paths:'
		cut -f1 <"$tmpdir"/list
		exit 1
	fi >&2

	is_dir_empty "$d" ||
		mv -v -t /usr"$d"/ "$d"/*

	p_ldconfig=/sbin/ldconfig
	[ -x "$p_ldconfig" ] ||
		p_ldconfig=/usr"$p_ldconfig"
	p_rmdir=/bin/rmdir
	[ -x "$p_rmdir" ] ||
		p_rmdir=/usr/bin/rmdir
	p_ln=/bin/ln
	[ -x "$p_ln" ] ||
		p_ln=/usr/bin/ln
	[ -x "$interp" ] ||
		interp="/usr$interp"

	"$p_ldconfig"
	"$interp" "$p_rmdir" "$d"
	"$interp" "$p_ln" -sn usr"$d" "$d"
done
